#!/usr/bin/perl -w
use strict;
use File::Basename;
use Getopt::Long qw/ :config gnu_getopt ignore_case /;
use lib '@X_DATADIR@/scr';
use scr_meta;
use scr_hash;

# requires: hostname, cp

my $prog = "scr_copy";

my $bindir = "@X_BINDIR@";

my $crc32 = "$bindir/scr_crc32";

# Usage:  scr_copy --from srcdir --to dstdir [failed nodes ...]
#   assumes local files are stored as $srcdir/filename
#   copy out as $dstdir/filename
#   exclude .scrinfo files

# print usage and exit
sub print_usage
{
  print "\n";
  print "  $prog -- copy files from checkpoint cache to parallel file system; run one copy per node\n";
  print "    $prog --gather --from <dir> --to <dir> [failed node list ...]\n";
  print "    e.g.:  $prog --gather --from /tmp/username/scr.jobid --to /p/lscratchb/username/prob2/current atlas31\n";
  print "\n";
  print "  Options:\n";
  print "    --from <dir>  - control directory where filemap files are located\n";
  print "    --to   <dir>  - checkpoint directory on the parallel file system files should be copied to\n";
  print "    --partner     - just copy partner's files\n";
  print "    --help        - print usage\n";
  print "\n";
  exit 1;
}

# read in environment variables and command line options
my %conf = ();
$conf{src}     = "";
$conf{dst}     = "";
$conf{checkpoint_id} = undef;
$conf{crc}     = undef;
$conf{help}    = 0;
$conf{scatter} = 0;
$conf{just_partner} = 0;
my $rc = GetOptions (
  "from=s"    => \$conf{src},
  "to=s"      => \$conf{dst},
  "id=i"      => \$conf{checkpoint_id},
  "crc"       => sub { $conf{crc} = 1; },
  "help|h"    => sub { $conf{help}    = 1; },
  "gather"    => sub { $conf{scatter} = 0; },
  "partner"   => sub { $conf{just_partner} = 1; },
);
if ($conf{help} or not $rc) { print_usage(); }

# read in list of failed nodes
my @failed = @ARGV;

# check that we have source and destination directories
if ($conf{src} eq "" or $conf{dst} eq "") { print_usage(); }

my $srcdir = $conf{src};
my $dstdir = $conf{dst};

# get my hostname for printing to the screen
my $hostname = `hostname`;
chomp $hostname;

# gather files from cache on each node to parallel file system
$rc = 0;

# if checkpoint_id is set, check that a flush file exists and that its checkpoint id matches
# this avoids flushing "stale" checkpoint files from old nodes
my $flush_id = undef;
if (defined $conf{checkpoint_id}) {
  # check whether we have the specified checkpoint id
  `$bindir/scr_flush_file --dir $conf{src} --haveid $conf{checkpoint_id}`;
  if ($? == 0) {
    # ok we have the checkpoint, let's remember it
    $flush_id = $conf{checkpoint_id};

    # if this checkpoint has already been flushed, return success immediately
    `$bindir/scr_flush_file --dir $conf{src} --needflush $flush_id`;
    if ($? != 0) {
      exit(0);
    }
  }

  # if we didn't find the checkpoint id, throw an error
  if (not defined $flush_id) {
    print "$prog: $hostname: Do not have CheckpointID $conf{checkpoint_id}.\n";
    print "$prog: $hostname: Return code: 1\n";
    exit(1);
  }
}

# TODO: just use most recent checkpoint if one is not specified?
# make sure we have a checkpoint id
if (not defined $flush_id) {
  print "$prog: $hostname: Must have a valid checkpoint id to flush\n";
  print "$prog: $hostname: Return code: 1\n";
  exit(1);
}

# read in the master filemap and then all filemaps on this node
my $f = {};
my $scr_hash = new scr_hash("$prog: $hostname");
my $h = $scr_hash->read_hash_file("$srcdir/filemap_node.scrinfo");
if (not defined $h) {
  print "$prog: $hostname: Could not find master filemap: $srcdir/filemap_node.scrinfo\n";
  print "$prog: $hostname: Return code: 1\n";
  exit(1);
}
my @filemaps = (keys %{$$h{'Filemap'}});
foreach my $filemap (@filemaps) {
  my $tmp_rc = read_filemap($filemap, $f);
  if ($tmp_rc != 0) {
    print "$prog: $hostname: Invalid filemap detected: $filemap\n";
    print "$prog: $hostname: Return code: 1\n";
    exit(1);
  }
}

# copy my files
if (not $conf{just_partner}) { 
  $rc = offload_files($dstdir, $f, $flush_id, undef);
  print "$prog: $hostname: Return code: $rc\n";
}

# get list of partner nodes I have files for
#  opendir(DIR, "$srcdir/scr_files");
#  my @partners = grep !/^\.\.?$/, readdir DIR;
#  closedir(DIR);
my @partners = list_partners($f, $flush_id); 
print "$prog: $hostname: Partners: " . join(" ", @partners) . "\n";

# if any partner failed, copy his files
foreach my $partner (@partners) {
  foreach my $fail (@failed) {
    if ($partner eq $fail) {
      print "$prog: $hostname: Partner failed: $fail\n";
      my $partner_rc = offload_files($dstdir, $f, $flush_id, $partner);
      print "$prog: $hostname: Return code: $partner_rc\n";
      if ($partner_rc > $rc) { $rc = $partner_rc; }
    }
  }
}

# all done
exit ($rc >> 8);

sub compute_crc
{
  my @files = @_;

  # exclude the meta files themselves
  @files = grep {($_ !~ /\.scr$/)} @files;

  # for each non .scr file, see if the file has a crc32
  #   if so, nothing to do
  #   if not, compute crc32 and update meta file
  my $m = new scr_meta();

  # get the full files first
  my @fullfiles = grep {($_ !~ /\.xor$/)} @files;
  foreach my $file (@fullfiles) {
    my $r = $m->read("$file");
    if (defined $r and defined $$r{'CRC32Computed'} and not $$r{'CRC32Computed'}) {
      my $crc = `$crc32 $file`;
      chomp $crc;
      $crc = "0x$crc";
      $$r{'CRC32Computed'} = 1;
      $$r{'CRC32'} = $crc;
      if (defined $$r{'Filetype'} and $$r{'Filetype'} == 0) {
        $$r{'SRCCRC32Computed'} = 1;
        $$r{'SRCCRC32'} = $crc;
      }
      $m->write("$file", $r);
    }
  }

  # now get the xor files (uses data computed for full file)
  my @xorfiles = grep {($_ =~ /\.xor$/)} @files;
  foreach my $file (@xorfiles) {
    my $dir = dirname($file);
    my $r = $m->read("$file");
    if (defined $r) {
      if (defined $$r{'CRC32Computed'} and not $$r{'CRC32Computed'}) {
        my $crc = `$crc32 $file`;
        chomp $crc;
        $crc = "0x$crc";
        $$r{'CRC32Computed'} = 1;
        $$r{'CRC32'} = $crc;
        if (defined $$r{'Filetype'} and $$r{'Filetype'} == 1) {
          my $r_src = $m->read($dir . "/" . $$r{'SRCFilename'});
          $$r{'SRCCRC32Computed'} = $$r_src{'CRC32Computed'};
          $$r{'SRCCRC32'} = $$r_src{'CRC32'};
        }
        $m->write("$file", $r);
      }
    }
  }
}

# copy_files(todir, @files)
sub copy_files
{
  my $to = shift @_;
  my @files = @_;

#  # get list of readable files in directory
#  opendir(DIR, $from);
#  my @files = grep {!/^\.\.?$/ and -f "$from/$_"} readdir DIR;
#  @files = grep {($_ !~ /\.scrinfo$/)} @files; # don't flush any *.scrinfo files
#  closedir(DIR);

  # check files for crc32 value and compute them if necessary before the copy, updates meta file
  if ($conf{crc}) { compute_crc(@files); }

  my $rc = 0;
  if (@files) {
    my $cmd = "cp -p " . join(" ", @files) . " $to/.";
    print "$prog: $hostname: $cmd\n";
    `$cmd`;
    $rc = $?;
  }
  return $rc;
}

sub offload_files
{
  my $dstdir = shift @_;
  my $f      = shift @_;
  my $ckpt   = shift @_;
  my $node   = shift @_;

  my $rc = 1;

  if (defined $f and defined $$f{checkpoints} and defined $$f{checkpoints}{$ckpt}) {
    $rc = 0;
    my $num_written = 0;
    my $ranks = \%{$$f{checkpoints}{$ckpt}{ranks}};
    foreach my $rank (keys %$ranks) {
      # TODO: need to tag this level as partner (not individiual files, since partner may not have any)
      my $write_this_rank = 1;
      my $expect = $$ranks{$rank}{expect};
      my $files = \%{$$ranks{$rank}{files}};
      my @file_list = (keys %$files);
      my @copy_list = ();
      my @map_list  = ();
      foreach my $file (@file_list) {
        if (defined $$files{$file}{tags}{'Partner'}) {
          if (defined $node and $$files{$file}{tags}{'Partner'} eq $node) {
            push @map_list, $file;
            push @copy_list, $file, $file . ".scr";
          } else {
            $write_this_rank = 0;
          }
        } else {
          if (not defined $node) {
            push @map_list, $file;
            push @copy_list, $file, $file . ".scr";
          } else {
            $write_this_rank = 0;
          }
        }
      }

      # check that we copied the same number of files that we expected to copy
      if ($write_this_rank) {
        $num_written++;
        if (@map_list == $expect) {
          # if we have at least one file, copy it out
          if (@copy_list > 0) {
            my $tmp_rc = copy_files($dstdir, @copy_list);
            if ($tmp_rc != 0) {
              print "$prog: $hostname: Error copying files for rank $rank\n";
              $rc = 1;
            }
          }

          # write out rank.scrfilemap file for this rank for scr_check_complete
          if (open(OUT, ">$dstdir/$rank.scrfilemap")) {
            print OUT "Rank: $rank\n";
            print OUT "CheckpointID: $ckpt\n";
            print OUT "Expect: $expect\n";
            foreach my $file (@map_list) {
              my $name = basename($file);
              print OUT "File: $name\n";
            }
            print OUT "End: 0\n";
            close(OUT);
          } else {
            print "$prog: $hostname: Could not open $dstdir/$rank.scrfilemap for writing\n";
            $rc = 1;
          }
        } else {
          print "$prog: $hostname: Number of files in the filemap " . scalar(@map_list) .
                " does not match the expected number of files $expect for rank $rank\n";
          $rc = 1;
        }
      }
    }
    if ($num_written == 0) {
      print "$prog: $hostname: Found no ranks to write\n";
      $rc = 1;
    }
  }

  return $rc;
}

sub list_partners
{
  my $f    = shift @_;
  my $ckpt = shift @_;

  my %partners = ();
  if (defined $f and defined $$f{checkpoints} and defined $$f{checkpoints}{$ckpt}) {
    my $ranks = \%{$$f{checkpoints}{$ckpt}{ranks}};
    foreach my $rank (keys %$ranks) {
      my $files = \%{$$ranks{$rank}{files}};
      foreach my $file (keys %$files) {
        if (defined $$files{$file}{tags}{'Partner'}) {
          $partners{$$files{$file}{tags}{'Partner'}} = 1;
        }
      }
    }
  }

  return (keys %partners);
}

sub read_filemap
{
  my $map = shift @_;
  my $f   = shift @_;

  if (not open(IN, $map)) { return 0; }
#print "FILEMAP: $map\n";

  my $found_end = 0;
  my $ckpt = undef;
  my $rank = undef;
  my $file = undef;
  while (my $line = <IN>) {
    chomp $line;
    if ($line =~ /CheckpointID: (\d+)/) {
      $ckpt = $1;
#print "CKPT $ckpt\n";
    } elsif ($line =~ /Rank: (\d+)/) {
      $rank = $1;
#print "RANK $rank\n";
    } elsif ($line =~ /Expect: (\d+)/) {
      $$f{checkpoints}{$ckpt}{ranks}{$rank}{expect} = $1;
#print "EXPECT $1\n";
    } elsif ($line =~ /File: (.*)/) {
      $file = $1;
#print "FILE $file\n";
      $$f{checkpoints}{$ckpt}{ranks}{$rank}{files}{$file}{name} = 1;
    } elsif ($line =~ /Tag: (.*)/) {
      my ($tag, $value) = ($1 =~ /(.*):(.*)/);
#print "TAG $tag, VALUE $value\n";
      $$f{checkpoints}{$ckpt}{ranks}{$rank}{files}{$file}{tags}{$tag} = $value;
    } elsif ($line =~ /End: (\d+)/) {
      $found_end = 1;
    }
  }

  close(IN);

  # TODO: check that for each checkpoint/rank we have the expected number of files

  if (!$found_end) { return 1; }

  return 0;
}
