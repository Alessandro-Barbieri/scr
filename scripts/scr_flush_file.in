#!/usr/bin/perl -w
use strict;
use Getopt::Long qw/ :config gnu_getopt ignore_case /;
use lib '@X_DATADIR@/scr';
use scr_hash;

# This script reads the flush file to determine whether given
# checkpoint ids exists and whether they need to be flushed

my $prog = "scr_flush_file";

sub print_usage
{
  print "\n";
  print "  Usage:  $prog --dir <dir> [--haveid <id> | --needflush <id> | --latest]\n";
  print "\n";
  exit 1;
}

# read in command line arguments
my %conf = ();
$conf{dir}       = undef;
$conf{haveid}    = undef;
$conf{needflush} = undef;
$conf{latest}    = undef;
$conf{verbose}   = 0;
my $rc = GetOptions (
   "dir|d=s"       => \$conf{dir},
   "haveid|h=i"    => \$conf{haveid},
   "needflush|n=i" => \$conf{needflush},
   "latest|l"      => sub { $conf{latest}  = 1; },
   "verbose|v"     => sub { $conf{verbose} = 1; },
);
if (not $rc) { print_usage(); }

# check that we got one of: haveid, needflush, or latest
if (not defined $conf{haveid} and
    not defined $conf{needflush} and
    not defined $conf{latest})
{
  print_usage();
}

# make sure we know where to look for the flush file
if (not defined $conf{dir}) { print_usage(); }

# get my hostname for printing to the screen
my $hostname = `hostname`;
chomp $hostname;

# read in the hash file
my $h = new scr_hash("$prog: $hostname");
my $flush = {};
if (not $h->read_file("$conf{dir}/flush.scrinfo", $flush)) {
  exit 1;
}

# check whether the specified id is defined in the flush file
if (defined $conf{haveid}) {
  if (defined $$flush{$conf{haveid}}) {
    exit 0;
  } else {
    exit 1;
  }
}

# check that we have the id, and check that it's not already been flushed,
# i.e., that it's not already in the parallel file system (PFS)
if (defined $conf{needflush}) {
  if (defined $$flush{$conf{needflush}} and
      not defined $$flush{$conf{needflush}}{"PFS"})
  {
    exit 0;
  }
  exit 1;
}

# return the id of the latest checkpoint
if (defined $conf{latest}) {
  my @ids = (sort {$b <=> $a} keys %$flush);
  if (@ids > 0) {
    my $latest = $ids[0];
    print "$latest\n";
    exit 0;
  } else {
    # TODO: want to print anything here?
#    print "No checkpoint found.\n";
    exit 1;
  }
}

#foreach my $id (sort {$b <=> $a} keys %$flush) {
##  print "CheckpointID: $id\n";
#  my @locs = ();
#  foreach my $loc (keys %{$$flush{$id}}) {
##    print "$loc\n";
#    push @locs, $loc;
#    foreach my $key (keys %{$$flush{$id}{$loc}}) {
##      print "$key --> $$flush{$id}{$loc}{$key}\n";
#    }
#  }
#  print "$id:" . join(",", @locs) . "\n";
#}

# shouldn't fall all the way through to here, so return an error
exit 1;
