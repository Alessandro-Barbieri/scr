#!/usr/bin/perl -w
use strict;
use Getopt::Long qw/ :config gnu_getopt ignore_case /;
use Date::Manip;

my $bindir = "@X_BINDIR@";
my $prog = "scr_halt";

# requires: pdsh, squeue, scontrol, scancel, umask (shell command)

# use absolute paths to internal commands
my $pdsh  = "@PDSH_EXE@";
my $bash  = "/bin/bash";
my $mkdir = "/bin/mkdir";
my $rm    = "/bin/rm";
my $echo  = "/bin/echo";
my $umask = "umask"; # shell command

my %conf = ();

$conf{usage} = <<EOF

  $prog -- set or modify halt conditions for an SCR job

  Usage:  $prog [options] [jobid ...]

  Options:
    -z, --all
          Halt all jobs on the system.
    -u, --user=LIST
          Halt all jobs for a comma-separated LIST of users.

    -c, --checkpoints=N
          Halt job after N checkpoints.
    -b, --before=TIME
          Halt job before specified TIME.  Uses SCR_HALT_SECONDS if set.
    -a, --after=TIME
          Halt job after specified TIME.
    -i, --immediate
          Halt job immediately.
    -s, --seconds=N
          Set or reset SCR_HALT_SECONDS for active job.

    -l, --list
          List the current halt conditions specified for a job or jobs.

    --unset-checkpoints
          Unset any checkpoint halt condition.
    --unset-before
          Unset any halt before condition.
    --unset-after
          Unset halt after condition.
    --unset-seconds
          Unset halt seconds.
    --unset-reason
          Unset the current halt reason.

    -r, --remove
          Remove halt file.

    -e, --every
          Write halt file to / remove halt file from every node in job allocation.
    -v, --verbose
          Increase verbosity.
    -h, --help
          Print usage.

LIST refers to a comma-separated list of words. All options
which take a LIST argument may also be specified multiple times
(e.g. --user=sally,tim --user=frank).

TIME arguments are parsed using the perl Date::Manip(3pm) package, and thus
may be specified in one of many formats. Examples include '12pm',
'yesterday,noon', '12/25-15:30:33', and so on. See the Date::Manip(3pm)
manpage for more examples.

If no jobid is specified, and --user and --all are not given, then
the jobid is set from the environment.  This feature is convenient when
invoking the command in job batch scripts.

EOF
;

# Initialize Date::Manip
Date_Init();

# print usage and exit
sub print_usage {
  print STDOUT $conf{usage};
  exit 1;
}

# read in environment variables and command line options
$conf{all}         = 0;
$conf{user}        = "";
$conf{checkpoints} = undef;
$conf{before}      = undef;
$conf{after}       = undef;
$conf{immdiate}    = 0;
$conf{seconds}     = undef;
$conf{list}        = undef;
$conf{unset_checkpoints} = undef;
$conf{unset_before}      = undef;
$conf{unset_after}       = undef;
$conf{unset_seconds}     = undef;
$conf{unset_reason}      = undef;
$conf{remove}      = 0;
$conf{every}       = 0;
$conf{verbose}     = 0;
$conf{help}        = 0;
my $rc = GetOptions (
  "all|z"       => \$conf{all},
  "user|u=s"    => \$conf{user},
  "checkpoints|c=i" => \$conf{checkpoints},
  "before|b=s"  => \$conf{before},
  "after|a=s"   => \$conf{after},
  "immediate|i" => \$conf{immediate},
  "seconds|s=i" => \$conf{seconds},
  "list|l"      => \$conf{list},
  "unset-checkpoints" => \$conf{unset_checkpoints},
  "unset-before"      => \$conf{unset_before},
  "unset-after"       => \$conf{unset_after},
  "unset-seconds"     => \$conf{unset_seconds},
  "unset-reason"      => \$conf{unset_reason},
  "remove|r"    => \$conf{remove},
  "every|e"     => \$conf{every},
  "verbose|v"   => \$conf{verbose},
  "help|h"      => \$conf{help},
);
if ($conf{help} or not $rc) {
  print_usage();
}

# get the jobids
my @jobids = ();
my @found_jobs = ();
my @missing_jobs = ();
if ($conf{all} or $conf{user}) {
  my $user_query = "";
  if ($conf{user}) {
    $user_query = "--user=$conf{user}";
  }
  my $jobs = `squeue $user_query --format=\%i -h`;
  chomp $jobs;
  @jobids = split("\n", $jobs);
  @found_jobs = @jobids;
} else {
  # check that we have at least one job listed
  if (@ARGV >= 1) {
    # if find some arguments on the command line, assume they are jobids
    @jobids = @ARGV;
  } else {
    # try to pick up jobid of the current job from environment
    my $jobid = `$bindir/scr_env --jobid`;
    if ($? != 0) {
      # couldn't find a job id, print usage and bail out
      print_usage();
    }
    chomp $jobid;
    push @jobids, $jobid;
  }

  # check that user gave a valid jobid
  my $jobs = join(",", @jobids);
  my $output = `squeue -o "%u %i" -j $jobs -h`;
  $rc = $?;
  if ($rc == 0) {
    foreach my $jobid (@jobids) {
      my $found = 0;
      foreach my $line (split "\n", $output) {
        my ($user, $id) = split /\s+/, $line;
        if ($id == $jobid) {
          $found = 1;
          last;
        }
      }
      if ($found) {
        push @found_jobs, $jobid;
      } else {
        push @missing_jobs, $jobid;
      }
    }
  }
}

foreach my $jobid (@missing_jobs) {
  print "$prog: ERROR: Could not find job $jobid\n";
}

my $ret = 0;

# TODO: a faster way to halt all jobs is to add first and last node of
# all jobs into a single pdsh list

# commands to build halt file
my @halt_conditions = ();

# halt after X checkpoints
if (defined $conf{checkpoints}) {
  my $checkpoints_left = $conf{checkpoints};
  # TODO: check that a valid value was given
  push @halt_conditions, "-c $checkpoints_left";
}

# halt before time
if (defined $conf{before}) {
  my $date = ParseDate($conf{before});
  if (not defined $date or not $date) {
    print "$prog: ERROR: Invalid time specified in --before: $conf{before}\n";
    exit 1;
  }
  my $secs = UnixDate($date,"%s");
#  print "$prog: Exit before: " . localtime($secs) . "\n";
  push @halt_conditions, "-b $secs";
}

# halt after time
if (defined $conf{after}) {
  my $date = ParseDate($conf{after});
  if (not defined $date or not $date) {
    print "$prog: ERROR: Invalid time specified in --after: $conf{after}\n";
    exit 1;
  }
  my $secs = UnixDate($date,"%s");
#  print "$prog: Exit after: " . localtime($secs) . "\n";
  push @halt_conditions, "-a $secs";
}

# set (reset) SCR_HALT_SECONDS value
if (defined $conf{seconds}) {
  my $halt_seconds = $conf{seconds};
  # TODO: check that a valid value was given
  push @halt_conditions, "-s $halt_seconds";
}

# list halt options
if (defined $conf{list}) {
  push @halt_conditions, "-l";
}

# push options to unset any values
if (defined $conf{unset_checkpoints}) {
  push @halt_conditions, "-xc";
}
if (defined $conf{unset_before}) {
  push @halt_conditions, "-xb";
}
if (defined $conf{unset_after}) {
  push @halt_conditions, "-xa";
}
if (defined $conf{unset_seconds}) {
  push @halt_conditions, "-xs";
}
if (defined $conf{unset_reason}) {
  push @halt_conditions, "-xr";
}

# if we were not given any conditions, set the exit reason to JOB_HALTED
if (not @halt_conditions or $conf{immediate}) {
  push @halt_conditions, "-r JOB_HALTED";
}

# the -r option overrides everything else
if ($conf{remove}) {
  @halt_conditions = ();
}

# create a halt file on each node
foreach my $jobid (@found_jobs) {
  my $rc = 0;

  print "Updating halt file for jobid $jobid ... \n";

  # lookup nodeset for jobid
  my $nodes_and_user = `squeue -j $jobid --format="\%N \%u" -h\n`;
  $rc = $?;
  if ($rc != 0) {
    print "\n";
    print "$prog: ERROR: Failed to find nodeset and username for job $jobid\n";
    $ret = 1;
    next;
  }
  my ($nodeset, $username) = split(/\s+/, $nodes_and_user);

  # build the name of the halt file
  my $cntldir = `$bindir/scr_cntl_dir --user $username --jobid $jobid`;
  chomp $cntldir;
  my $halt_file = "$cntldir/halt.scrinfo";

  # TODO: Set halt file permissions so system admins can modify them
  # Create directory containing the halt file (and the halt file itself) with umask 000.
  # This gives everyone read/write/execute access to the directory and the halt file,
  # which enables system administrators to halt a user's job without having to login as the user.
  # This is useful to halt all jobs on the machine with a single command (scr_halt -a).
  # For now, this is secure so long as only the user (and the admin) can can access
  # the nodes is the user's job is running on.
  # A better solution: create a separate directory for the halt file so permissions on
  # the entire checkpoint cache are not wide open.
  #
  my $halt_cmd = "";
  if (@halt_conditions) {
    # create the halt file with specified conditions
    my $halt_file_options = join(" ", @halt_conditions);
    $halt_cmd = "$bash -c \"$umask 000; $mkdir -p $cntldir; $bindir/scr_halt_cntl -f $halt_file $halt_file_options;\"";
  } else {
    # remove the halt file
    $halt_cmd = "$bash -c \"$rm -f $halt_file\"";
  }

  # write to just the first node in the allocation if every is not set
  if (not $conf{every}) {
    my $first_node = `$bindir/scr_glob_hosts -n 1 -h '$nodeset'`;
    $nodeset = $first_node;
  }

  # pdsh the command to the nodeset
  chomp $nodeset;
  if ($conf{verbose}) {
    print "\n`$pdsh -f 128 -w '$nodeset' '$halt_cmd'`\n";
  }
  my $pdsh_output = `$pdsh -f 128 -w '$nodeset' '$halt_cmd'`;
  $rc = $?;
  if ($rc != 0) {
    print "\n";
    print "$prog: ERROR: Failed to create halt file for job $jobid\n";
    $ret = 1;
  }

  # dispaly the current halt file settings
  if (not $conf{every}) {
    print "\n";
    print "$pdsh_output\n";
  } else {
    # we do this to prevent too much data from blasting to the screen, maybe it's not necessary?
    if ($conf{list}) {
      print "$prog: ERROR: Can not --list halt file on --every node\n";
    }
  }
}

# TODO: would like to protect against killing a job in the middle of a checkpoint if possible

# kill job if immediate was set
if ($conf{immediate}) {
  if (@found_jobs > 0) {
    print "Cancelling job steps ...\n";
  }
  foreach my $jobid (@found_jobs) {
    my $rc = 0;

    my $scontrol = `scontrol show step $jobid`;
    if ($? == 0) {
      my @lines = split("\n", $scontrol);
      my @steps = ();
      foreach my $line (@lines) {
        if ($line =~ /StepId=(\d+\.\d+)/) {
          my $step = $1;
          # don't want to cancel jobid.0 (that's the allocation, not a step)
          if ($step ne "$jobid.0") {
            push @steps, $1;
          }
        }
      }
      if (@steps > 0) {
        my $steps = join(" ", @steps);
        print "  scancel $steps\n";
        `scancel $steps`;
        $rc = $?;
        if ($rc != 0) {
          print "$prog: ERROR: Failed to cancel job steps $steps\n";
          $ret = 1;
        }
      }
    } else {
      print "$prog: ERROR: Failed to lookup job step ids for jobid $jobid\n";
      $ret = 1;
    }
  }
}

exit $ret;
