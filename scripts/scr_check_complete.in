#!/usr/bin/perl -w
use strict;
use File::Basename;
use Getopt::Long qw/ :config gnu_getopt ignore_case /;
use lib '@X_DATADIR@/scr';
use scr_meta;
use scr_hash;

my $prog = "scr_check_complete";

my $bindir = "@X_BINDIR@";
my $rebuild = "$bindir/scr_rebuild_xor";

# SCR filetype constants
my $SCR_FILE_FULL = 0;
my $SCR_FILE_XOR  = 2;

# log the start time for the check complete operation
my $start_time = time();
`$bindir/scr_log_event -T 'CHECK COMPLETE STARTED' -S $start_time`;

# Given a directory where checkpoint files and their corresponding .scr files
# were copied to, determine whether we gathered a complete set of checkpoint files
# Must have:
#   * checkpoint file from every process
#   * each file must be marked as valid
#   * each file must be of the correct byte count
#   * each file must be on the same scr checkpoint id
#   * all files must be consistent with the number of ranks participating
#   * DO NOT: verify crc32 values (this could take a long time, defer this to fetch operation)

# print usage and exit
sub print_usage
{
  print "\n";
  print "  scr_check_complete -- utility to check whether a checkpoint set is complete\n";
  print "\n";
  print "  Usage:  scr_check_complete <checkpoint_dir>\n";
  print "   e.g.:  scr_check_complete /p/lscratchb/username/run1/checkpoints/current\n";
  print "\n";
  exit 1;
}

# read in environment variables and command line options
my %conf = ();
$conf{dst}     = "";
my $rc = GetOptions (
#  "pattern|p=s"    => \$conf{pattern},
);
if (not $rc) {
  print_usage();
}

# should have one argument remaining which is the checkpoint directory
if (@ARGV != 1) {
  print_usage();
}
$conf{dst} = shift @ARGV;

# check that source and destination directories are defined
if ($conf{dst} eq "") {
  print "$prog: ERROR: Must specify checkpoint directory.\n";
  print_usage();
  exit 1;
}
my $from = $conf{dst};

# read each file and record details
my %ranks = ();
my %global_map = ();
my $maxiter  = -1;
my $maxranks = -1;

my %xorsets = ();

# read each file and record details
scan_files($from);
my ($num_files, $using_xor, @ranks_missing_files) = check_all_files();

my %missing_full = ();
foreach my $rank (@ranks_missing_files) {
  $missing_full{$rank} = 1;
}

my @unrecoverable_ranks = ();
my %recoverable = ();

# TODO: integrate this into the main logic
# if we have any missing files, see if we can make a stab at rebuilding them
if ($using_xor and scalar(keys %missing_full) > 0) {
  foreach my $gid (keys %xorsets) {
    # got an xor set, now get its size
    my $s = \%{$xorsets{$gid}};
    my $size = $$s{size};

    # check whether we have the files for each member of the set
    my $missing_index = undef;
    my @full_filenames = ();
    my @xor_filenames  = ();
    for (my $index = 0; $index < $size; $index++) {
      if (defined $$s{indicies}{$index}) {
        my $i = \%{$$s{indicies}{$index}};
        my $rank = $$i{rank};
        if (not defined $missing_full{$rank}) {
          # we have all files for this rank, add its xor file to the set
          push @xor_filenames, $$i{'xor'};
        } else {
          # have some file for this member, but it didn't pass the integrity check
          $missing_index = $index;
        }
      } else {
        # missing a member from this set
        $missing_index = $index;
      }
    }

    # if we don't have a complete set, but we have enough files to attempt to build it, create the command
    if (defined $missing_index) {
      my $xor_set_name = $gid;
      if (@xor_filenames >= $size-1) {
        my $xor_file_list  = join(" ", @xor_filenames);
        my $missing_xor_file = ($missing_index + 1) . "_of_$size" . "_in_$xor_set_name.xor";
        $recoverable{$xor_set_name}{cmd} = "$rebuild $size $missing_index $missing_xor_file $xor_file_list";
      } else {
        # rank did not have xor file, and we're missing its full file... out of luck
        print "$prog: FAILURE: No files available to attempt rebuild missing file in xor set $xor_set_name\n";
        push @unrecoverable_ranks, $xor_set_name;
      }
    }
  }
}

# for each missing full file, check whether it can be reconstructed
if (not $using_xor) {
  foreach my $rank (sort {$a <=> $b} keys %missing_full) {
    push @unrecoverable_ranks, $rank;
  }
}

# if any files can not be reconstructed, add their ranks to the missing ranks set
my $rebuild_attempted = 0;
my @missing_ranks = ();
if (@unrecoverable_ranks > 0) {
  print "$prog: ERROR: Can't recover files for the following ranks or xor sets: " . join(", ", @unrecoverable_ranks) . "\n";
  @missing_ranks = @unrecoverable_ranks;
} else {
  # if we need to rebuild, note the start time in the logs
  if ((keys %recoverable) > 0) {
    $rebuild_attempted = 1;
    `$bindir/scr_log_event -T 'REBUILD STARTED' -C $maxiter -S $start_time`;
  }

  # since each file could take a while to rebuild, and because we have multicores,
  # we may as well spawn up several processes to do this work
  foreach my $rank (sort {$a cmp $b} keys %recoverable) {
    print "$prog: Attempting to rebuild file for rank $rank ... \n";
    print "\n$recoverable{$rank}{cmd}\n\n";
    $recoverable{$rank}{pid} = fork();
    if ($recoverable{$rank}{pid} == 0) {
      `cd $from && $recoverable{$rank}{cmd}`;
      if ($? == 0) {
        exit 0;
      }
      exit 1;
    }
  }

  # now wait on each child process to finish
  foreach my $rank (sort {$a cmp $b} keys %recoverable) {
    my $rebuilt_file = 0;
    my $ret = waitpid($recoverable{$rank}{pid}, 0);
    if ($? == 0) {
      $rebuilt_file = 1;
      print "$prog: SUCCESS: Rebuilt file for xor set $rank.\n";
    } else {
      print "$prog: FAILURE: Could not rebuild file for xor set $rank.\n";
    }

    # if we couldn't rebuild the file, mark this rank as missing
    if (not $rebuilt_file) {
      push @missing_ranks, $rank;
      next;
    }
  }
}

# rescan files if any ranks were successfully rebuilt to refresh our data structures
if ((keys %recoverable) > 0) { 
  scan_files($from);
  ($num_files, $using_xor, @ranks_missing_files) = check_all_files();
}

if (@ranks_missing_files == 0) {
  # count the number of full files that we have across all ranks
  my $num_full_files = 0;
  for(my $i=0; $i<$maxranks; $i++) {
    my @full_files = (keys %{$ranks{$i}{type}{$SCR_FILE_FULL}});
    $num_full_files += scalar(@full_files);
  }

  my $summary = "$from/scr_summary.txt";
  print "$prog: Writing $summary ...\n";
  open(OUT, ">$summary");
  print OUT "Version: 3\n";
  print OUT "Rows: $num_full_files\n";
  print OUT "Rank\tSCR\tRanks\tID\tComp\tExpSize\tExists\tSize\tFilename\tCRC32Computed\tCRC32\n";

  # for each rank, write out a record for each full file
  for(my $i=0; $i<$maxranks; $i++) {
    my @full_files = (keys %{$ranks{$i}{type}{$SCR_FILE_FULL}});
    foreach my $file (@full_files) {
      my $h = $ranks{$i}{type}{$SCR_FILE_FULL}{$file};

      # record a line in the summary file
      print OUT "$i\t1\t$$h{meta}{ranks}\t";
      print OUT "$$h{meta}{iter}\t$$h{meta}{comp}\t$$h{meta}{size}\t";
      print OUT "$$h{real}{exist}\t$$h{real}{size}\t" . basename($$h{real}{file});
      print OUT "\t$$h{meta}{crc32computed}\t$$h{meta}{crc32}";
      print OUT "\n";
    }
  }

  print OUT "\n";
  close(OUT);
}

# get a timestamp for logging timing values
my $end_time = time();
my $diff_time = $end_time - $start_time;

# if we're missing any rank, exit with an error
if (@missing_ranks > 0) {
  print "$prog: INCOMPLETE: Missing ranks or xor sets: ", join(",", @missing_ranks), "\n";

  # if we tried to rebuild, note the start time in the logs
  if ($rebuild_attempted) {
    `$bindir/scr_log_event -T 'REBUILD FAILED' -C $maxiter -S $start_time -D $diff_time`;
  }
  `$bindir/scr_log_event -T 'CHECK COMPLETE FAILED' -C $maxiter -S $start_time -D $diff_time`;

  exit 1;
}

# otherwise, we have a complete set
print "$prog: COMPLETE\n";
# if we tried to rebuild, note the start time in the logs
if ($rebuild_attempted) {
  `$bindir/scr_log_event -T 'REBUILD SUCCEEDED' -C $maxiter -S $start_time -D $diff_time`;
}
`$bindir/scr_log_event -T 'CHECK COMPLETE SUCCEEDED' -C $maxiter -S $start_time -D $diff_time`;
exit 0;

# read_info(scr_file) - reads values out of .scr file
sub read_info
{
  my $file = shift @_;
  my $h    = shift @_;

  $$h{rank}     = -1;
  $$h{ranks}    = -1;
  $$h{count}    = -1;
  $$h{complete} =  0;
  $$h{filesize} = -1;

  open(IN, $file);
  while(my $line = <IN>) {
    chomp $line;
    my ($name, $val) = split(/\s+/, $line);         
    if    ($name eq "Rank:")         { $$h{rank}         = int($val); }
    elsif ($name eq "Ranks:")        { $$h{ranks}        = int($val); }
    elsif ($name eq "CheckpointID:") { $$h{count}        = int($val); }
    elsif ($name eq "Filetype:")     { $$h{filetype}     = int($val); }
    elsif ($name eq "Filename:")     { $$h{filename}     = basename($val); }
    elsif ($name eq "Filesize:")     { $$h{filesize}     = int($val); }
    elsif ($name eq "Complete:")     { $$h{complete}     = int($val); }
    elsif ($name eq "CRC32Computed:"){ $$h{crc32computed} = int($val); }
    elsif ($name eq "CRC32:")        { $$h{crc32}        = $val; }
  } 
  close(IN);

  # TODO: these should be fields in the file (not in the title)
  if ($file =~ /(\d+)_of_(\d+)_in_(\d+).xor/) {
    $$h{xor_gid}   = $3;
    $$h{xor_size}  = $2;
    $$h{xor_index} = $1 - 1;
  }

  return;
}

sub scan_files
{
  my $from = shift @_;

  # get list of readable files in directory
  opendir(DIR, $from) || die "$prog: ERROR: Could not access checkpoint directory: $from\n";
  my @files = grep {!/^\.\.?$/ and -f "$from/$_"} readdir DIR;

  # filter by .scr extension
  @files = grep {($_ =~ /\.scr$/)} @files;
  closedir(DIR);

  # if there are no scr files, then assume we failed
  if (@files == 0) {
    print "$prog: INCOMPLETE: No .scr files found.\n";
    exit 1;
  }

  foreach my $file (@files) {
    # read the .scr file
    my $filepath = "$from/$file";
    my %info = ();
    read_info($filepath, \%info);

    my $rank = $info{rank};

    # record the details
    my $h = {};
    $$h{meta}{file}  = $filepath;
    $$h{meta}{ranks} = $info{ranks};
    $$h{meta}{iter}  = $info{count};
    $$h{meta}{name}  = $info{filename};
    $$h{meta}{size}  = $info{filesize};
    $$h{meta}{comp}  = $info{complete};
    $$h{meta}{crc32computed} = 0;
    $$h{meta}{crc32}         = "0x0";
    if (defined $info{crc32}) {
      $$h{meta}{crc32computed} = $info{crc32computed};
      $$h{meta}{crc32}         = $info{crc32};
    }
    if ($info{filetype} == $SCR_FILE_XOR) {
      $$h{meta}{xor_gid}   = $info{xor_gid};
      $$h{meta}{xor_size}  = $info{xor_size};
      $$h{meta}{xor_index} = $info{xor_index};

      # TODO: ensure that all xor files belonging to the same xor set believe the xor set size is the same
      # TODO: if size is already set for this xor set, and our size value is different, throw an error
      $xorsets{$info{xor_gid}}{size} = $info{xor_size};
      $xorsets{$info{xor_gid}}{indicies}{$info{xor_index}}{rank}  = $rank;
      $xorsets{$info{xor_gid}}{indicies}{$info{xor_index}}{'xor'} = $info{filename};
    }

    # need to ensure that all files agree on number of ranks and the checkpoint id
    if ($maxranks < $info{ranks}) {
      $maxranks = $info{ranks};
    }
    if ($maxiter < $info{count}) {
      $maxiter  = $info{count};
    }

    # TODO: need to check filename listed in .scr file with name of real file
    # check that real file (same name w/o .scr extension) exists and record its size
    my $realfile = $filepath;
    $realfile =~ s/\.scr$//; # drop the .scr extension
    $$h{real}{file}  = $realfile;
    $$h{real}{exist} = 0;
    $$h{real}{size}  = 0;
    if (-e $realfile) {
      $$h{real}{exist} = 1;
      $$h{real}{size}  = (stat $realfile)[7];
    }

    # add this file to the set
    $ranks{$rank}{type}{$info{filetype}}{$info{filename}} = $h;
  }

  # now that we know the max ranks, read in the filemap for each rank to check that we have each file
  my $scr_hash = new scr_hash($prog);
  for (my $i = 0; $i < $maxranks; $i++) {
    my $filemap = "$from/$i.scrfilemap";
    my $tmp_rc = $scr_hash->read_file($filemap, \%global_map);
  }
}

# for each rank, check which files exist
sub check_file
{
  my $h = shift @_;
  
  # check values against real file and against rest of process set
  if ($$h{real}{exist} and                # file exists
      $$h{meta}{comp} and                 # file was explicitly marked as complete
      $$h{meta}{iter}  == $maxiter and    # file belongs to the expected checkpoint id
      $$h{meta}{ranks} == $maxranks and   # file belongs to the expected number of ranks
      $$h{meta}{size}  == $$h{real}{size} # file is the correct size
     )
  {
    return 1;
  }
  return 0;
}

sub check_all_files
{
  my $num_files = 0;
  my $using_xor = 0;
  my %missing_ranks = ();

  for(my $i=0; $i<$maxranks; $i++)
  {
    # if the process does not have a filemap, we must assume it's incomplete
    if (not defined $global_map{RANK}{$i}{CKPT}{$maxiter}) {
      $missing_ranks{$i} = 1;
      # nothing else to do, go on to next rank
      next;
    }

    # check whether we have this rank's full file
    my $num_have = 0;
    my $num_expect = (keys %{$global_map{RANK}{$i}{CKPT}{$maxiter}{EXPECT}})[0];
    $num_files += $num_expect;

    # check whether we have this rank's full files
    my @full_files = (keys %{$ranks{$i}{type}{$SCR_FILE_FULL}});
    foreach my $file (@full_files) {
      my $h = $ranks{$i}{type}{$SCR_FILE_FULL}{$file};
  
      # check values against real file and against rest of process set
      if (check_file($h)) {
        $num_have++;
      }
    }

    # check whether we have this rank's xor file
    my @xor_files = (keys %{$ranks{$i}{type}{$SCR_FILE_XOR}});
    foreach my $file (@xor_files) {
      $using_xor = 1;
      my $h = $ranks{$i}{type}{$SCR_FILE_XOR}{$file};

      # check values against real file and against rest of process set
      # check values against real file and against rest of process set
      if (check_file($h)) {
        $num_have++;
      }
    }

    # check that we found all of the files we expected to find, mark this rank if not
    if ($num_have != $num_expect) {
      $missing_ranks{$i} = 1;
    }
  }

  return ($num_files, $using_xor, (sort {$a <=> $b} keys %missing_ranks));
}
